# -*- coding: utf-8 -*-
"""NAR.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KQkFFUDCDxNPEqrssf8JaltqhU0DAMAJ
"""

import torch
import torchvision
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split

wb = pd.read_excel('Data_try.xlsx')

# training_data, testing_data = train_test_split(wb, test_size=0.2, random_state=25)
x=wb.values

X=[]
l=0
u=28  #Delay of 28 time steps
for i in range(0,1886):  #Data handling for NARX network
  A=[]
  for i in range(l,u):
    A.append(x[0][i])
  X.append(A)
  l=l+1
  u=u+1

Y=[]
l=28
u=56
for i in range(0,1886): 
  A=[]
  for i in range(l,u):
    A.append(x[0][i])
  Y.append(A)
  l=l+1
  u=u+1

X_train=[X[0:1500]]
X_test=[X[1500:np.shape(X)[0]]]
X_train=np.reshape(X_train,[1500,28])
X_train=torch.FloatTensor(X_train)
X_test=np.reshape(X_test,[386,28])
X_test=torch.FloatTensor(X_test)

Y_train=[Y[0:1500]]
Y_test=[Y[1500:np.shape(Y)[0]]]
Y_train=np.reshape(Y_train,[1500,28])
# Y_train=torch.Tensor([-1,0,1]).to(torch.long)
Y_train=torch.FloatTensor(Y_train)
Y_test=np.reshape(Y_test,[386,28])
Y_test=torch.LongTensor(Y_test)

class NeuralNetwork(torch.nn.Module):
  def __init__(self):
    super(NeuralNetwork,self).__init__()
    self.Network=torch.nn.Sequential(torch.nn.Linear(28,20), torch.nn.ReLU(),
                                    torch.nn.Linear(20,4), torch.nn.ReLU(), 
                                    torch.nn.Linear(4,3), torch.nn.ReLU(), 
                                    torch.nn.Linear(3,10),torch.nn.ReLU(), 
                                    torch.nn.Linear(10,28))
    
  def forward(self,x):
    # x=x.view(-1,28)
    transformed_x=self.Network(x)
    return transformed_x

net=NeuralNetwork()
Loss=torch.nn.MSELoss()
Optimizer=torch.optim.Adam(net.parameters(),lr=0.001)

Train_loss_history=[]
Test_loss_history=[]
for epoch in range(10):
  Train_loss=0
  Test_loss=0
  for i in range(0,np.shape(X_train)[0]):
    input=X_train[i][:]
    labels = Y_train[i][:]
    
    Optimizer.zero_grad()




    # input=torch.tensor(input)
    # labels=torch.Tensor(labels)
    Predicted_output=net(input)
    # Predicted_output=torch.FloatTensor(Predicted_output)
    # Predicted_output = Predicted_output[:, 0]
    # tr = torch.Tensor([0, 1, 0]).to(torch.long)
    fit=Loss(Predicted_output,labels)
    fit.backward()
    Optimizer.step()
    Train_loss+=fit.item()
  for i in range(0,np.shape(X_test)[0]):
    with torch.no_grad():
      input=X_test[i][:]
      labels = Y_test[i][:]
      #input=torch.LongTensor(input)
      #labels=torch.LongTensor(labels)
      Predicted_output=net(input)
      fit=Loss(Predicted_output,labels)
      Test_loss+=fit.item()
  Train_loss=Train_loss/len(X_train)
  Test_loss=Test_loss/len(X_test)
  Train_loss_history.append(Train_loss)
  Test_loss_history.append(Test_loss)
  print("the train loss and test loss in iteration %s is %s and %s"%(epoch,Train_loss,Test_loss))

Predicted_output=net(input)
Misclassifications=0
for i in range(0, len(Predicted_output)):
  Compare=torch.argmax(Predicted_output[i])==Y_test[i]
  if Compare[i] == True:
    Misclassifications+=1
    
Test_accuracy=(Misclassifications/len(Predicted_output))*100
print("The test accuracy is %s %s "%(Test_accuracy,'%'))

 # plt.plot(range(epoch+1),Train_loss_history,label='Train')
 # plt.plot(range(epoch+1),Test_loss_history,label="Test")
 # plt.legend()